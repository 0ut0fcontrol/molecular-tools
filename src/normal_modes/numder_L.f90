program numder_fc


    !==============================================================
    ! This code uses of MOLECULAR_TOOLS (version 1.0/March 2012)
    !==============================================================
    !
    ! Description:
    ! -----------
    ! Program to compute the numerical freqs from G09 scan
    !
    ! Compilation instructions (for mymake script):
    !
    ! Change log:
    !
    ! TODO:
    ! ------
    !
    ! History

    !
    !============================================================================    

!*****************
!   MODULE LOAD
!*****************
!============================================
!   Generic (structure_types independent)
!============================================
    use alerts
    use line_preprocess
    use constants
    use generic_io
    use vibrational_analysis
    use verbosity

    implicit none

    integer,parameter :: NDIM=600

    !====================== 
    ! PES topology and normal mode things
    real(8),dimension(1:5,1:NDIM,1:NDIM) :: LL
    real(8),dimension(1:NDIM,1:NDIM) :: Lref
    real(8),dimension(1:NDIM,1:NDIM) :: LderQj, Drot
    real(8),dimension(1:NDIM*NDIM)   :: Hlt
    real(8),dimension(NDIM) :: Freq, X, Y, Z, Mass
    character(len=2),dimension(NDIM) :: AtName
    integer :: error
    integer :: Nat, Nvib
    logical :: do_Lt=.false.
    !====================== 

    real(8),dimension(5) :: R
    real(8) :: factor
    logical :: corrected
    character(len=200) :: line, dummy_char
    character(len=13)  :: marker
    character(len=3)   :: density="SCF"

    integer :: Na, Nb
    integer :: i,j,k, istep, iread, IOstatus, ii

    !================
    !I/O stuff 
    !units
    integer :: I_INP=10, & 
               O_DER=20
    !files
    character(len=200):: inpfile ="input.log", &
                         reffile ="reference.log"

! (End of variables declaration) 
!==================================================================================

    ! 0. GET COMMAND LINE ARGUMENTS
    call parse_input(inpfile,reffile,density,do_Lt)
    call set_word_upper_case(density)

    if (adjustl(density) == "SCF") then
        marker="SCF Done:  E("
    elseif (adjustl(density) == "TD") then
        marker="E(TD-HF/TD-KS"
    else
        print*, "Unkown density: "//density
        stop
    endif

    ! We first perform a vibrational analysis on the refrence
    ! to get the reference Ekart frame to be used in the other cases
    open(I_INP,file=reffile,status="old")
    call generic_structure_reader(I_INP,'log-inpori',Nat,X,Y,Z,Mass,AtName,error)
    call generic_Hessian_reader(I_INP,'log',Nat,Hlt,error)
    close(I_INP)
    call vibrations_Cart(Nat,X,Y,Z,Mass,Hlt,Nvib,Lref(:,:),Freq,error_flag=error,&
                         Dout=Drot(1:3*Nat,1:3*Nat+6))

    open(I_INP,file=inpfile,status="old")

    istep=1
    iread=0
    do while ( IOstatus == 0 )
        read(I_INP,'(X,A)',IOSTAT=IOstatus) line
        if ( INDEX(line,"Disp =") /= 0 ) then
            if (iread/=0) cycle
            call split_line(line,'=',dummy_char,line)
            call generic_structure_reader(I_INP,'log-inpori',Nat,X,Y,Z,Mass,AtName,error)
            read(line,*) R(istep)
            call generic_Hessian_reader(I_INP,'log',Nat,Hlt,error)
            print*, "Reading step...", istep, R(istep)
            call vibrations_Cart(Nat,X,Y,Z,Mass,Hlt,Nvib,LL(istep,:,:),Freq,error_flag=error)!,&
!                                  Din=Drot)
            istep=istep+1
            iread=1
        else if ( INDEX(line,"Normal termination") /= 0 ) then
            iread=0
        endif
    enddo
    if (istep-1/=5) call alert_msg("fatal","logfile has not the the required number of steps."//&
                                           " Was it generated by nm_internal or nm_cartesian?") 
    print*, ""


    !Assume always the sign at equil. Correct using an element for the whole row
    do istep=1,5
        do k=1,Nvib
            do i=1,3*Nat
                !use an element significantly large
                corrected=.false.
                if (abs(LL(istep,i,k)) > 0.2d0) then
                    if ( LL(istep,i,k) == sign(LL(istep,i,k),Lref(i,k)) ) then
                        factor=1.d0
                    else
                        factor=-1.d0
                    endif
                    corrected=.true.
                    exit
                endif
            enddo
            if (.not.corrected) call alert_msg("fatal","Could not correct the signs")
            LL(istep,1:3*Nat,k) = LL(istep,1:3*Nat,k) * factor
print*, "checking signs", factor
do ii=1,3*Nat
    print'(2F12.4)', LL(istep,ii,k), Lref(ii,k)
enddo
        enddo
        ! Work in Cartesian coords
        call Lmwc_to_Lcart(Nat,Nvib,Mass,LL(istep,:,:),LL(istep,:,:),error)
    enddo


    !    L(Na,   Nb)
    ! Lder(Na,Nb,Nb)
    if (do_Lt) then
        Na = Nvib
        Nb = 3*Nat
        do istep=1,5
            LL(istep,:,:) = transpose(LL(istep,:,:))
        enddo
    else 
        Na = 3*Nat
        Nb = Nvib
    endif


    ! Small disp R(4) - R(2)
    do i=1,Na
    do k=1,Nb
        LderQj(i,k) = ( LL(4,i,k) - LL(2,i,k) ) / ( R(4) - R(2) )
    enddo
    enddo
    !print derivates
    open(O_DER,file='Ders_s_disp.dat') 
    do i=1,Na
        write(O_DER,'(600(E15.8,X))') LderQj(i,1:Nb)
    enddo
    close(O_DER)

    ! Large disp R(5) - R(1)
    do i=1,Na
    do k=1,Nb
        LderQj(i,k) = ( LL(5,i,k) - LL(1,i,k) ) / ( R(5) - R(1) )
    enddo
    enddo
    !print derivates
    open(O_DER,file='Ders_l_disp.dat') 
    do i=1,Na
        write(O_DER,'(600(E15.8,X))') LderQj(i,1:Nb)
    enddo
    close(O_DER)

    ! And write the L at equilibrium for further checking
    open(O_DER,file='Lmatrix_ref.dat') 
    do i=1,Na
        write(O_DER,'(600(E15.8,X))') LL(3,i,1:Nb)
    enddo
    close(O_DER)

    stop


    !==============================================
    contains
    !=============================================

    subroutine parse_input(inpfile,reffile,density,do_Lt)
    !==================================================
    ! My input parser (gromacs style)
    !==================================================
        implicit none

        character(len=*),intent(inout) :: inpfile, density, reffile
        logical                        :: do_Lt
        ! Local
        logical :: argument_retrieved,  &
                   need_help = .false.
        integer:: i
        character(len=200) :: arg
        ! iargc type must be specified with implicit none (strict compilation)
        integer :: iargc

        argument_retrieved=.false.
        do i=1,iargc()
            if (argument_retrieved) then
                argument_retrieved=.false.
                cycle
            endif
            call getarg(i, arg) 
            select case (adjustl(arg))
                case ("-f") 
                    call getarg(i+1, inpfile)
                    argument_retrieved=.true.

                case ("-ref") 
                    call getarg(i+1, reffile)
                    argument_retrieved=.true.

                case ("-Lt") 
                    do_Lt=.true.
                case ("-noLt") 
                    do_Lt=.false.

                case ("-dens") 
                    call getarg(i+1, density)
                    argument_retrieved=.true.
        
                case ("-h")
                    need_help=.true.

                ! Control verbosity
                case ("-quiet")
                    verbose=0
                    silent_notes = .true.
                case ("-concise")
                    verbose=1
                case ("-v")
                    verbose=2
                case ("-vv")
                    verbose=3
                    silent_notes=.false.


                case default
                    print*, "Unkown command line argument: "//adjustl(arg)
                    stop
                    call alert_msg("fatal","Unkown command line argument: "//adjustl(arg))
            end select
        enddo 

       !Print options (to stderr)
        write(0,'(/,A)') '--------------------------------------------------'
        write(0,'(/,A)') '          NUM DERIVATIVES FROM G09log FILE '          
        write(0,'(/,A)') '--------------------------------------------------'
        write(0,*) '-f              ', trim(adjustl(inpfile))
        write(0,*) '-dens           ', trim(adjustl(density))
        write(0,*) '-[no]Lt        ', do_Lt
        write(0,*) '-ref           ', trim(adjustl(reffile))
        write(0,*) '-h             ',  need_help
        write(0,*) '--------------------------------------------------'
        if (need_help) call alert_msg("fatal", 'There is no manual (for the moment)' )

        return
    end subroutine parse_input
       

end program numder_fc

